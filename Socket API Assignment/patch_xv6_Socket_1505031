commit ec12f887c5ab0ceb87a74f537f5c37c076c2a7bd
Author: gahab <1505031.zw@ugrad.cse.buet.ac.bd>
Date:   Sat Jan 19 06:39:14 2019 -0500

    commit done

diff --git a/Makefile b/Makefile
index 09d790c..e011a93 100644
--- a/Makefile
+++ b/Makefile
@@ -16,12 +16,14 @@ OBJS = \
 	pipe.o\
 	proc.o\
 	sleeplock.o\
+	sock.o\
 	spinlock.o\
 	string.o\
 	swtch.o\
 	syscall.o\
 	sysfile.o\
 	sysproc.o\
+	syssock.o\
 	trapasm.o\
 	trap.o\
 	uart.o\
@@ -181,6 +183,7 @@ UPROGS=\
 	_usertests\
 	_wc\
 	_zombie\
+	_socktest\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
diff --git a/defs.h b/defs.h
index 82fb982..e88c9fb 100644
--- a/defs.h
+++ b/defs.h
@@ -121,6 +121,14 @@ int             wait(void);
 void            wakeup(void*);
 void            yield(void);
 
+// sock.c
+void            sinit(void);
+int             listen(int);
+int             connect(int, const char*);
+int             send(int, const char*, int);
+int             recv(int, char*, int);
+int             disconnect(int);
+
 // swtch.S
 void            swtch(struct context**, struct context*);
 
@@ -188,3 +196,10 @@ void            clearpteu(pde_t *pgdir, char *uva);
 
 // number of elements in fixed-size array
 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
+
+//modifed
+#define E_NOTFOUND -1025
+#define E_ACCESS_DENIED -1026
+#define E_WRONG_STATE -1027
+#define E_FAIL -1028
+#define E_INVALID_ARG -1029
\ No newline at end of file
diff --git a/main.c b/main.c
index 9924e64..ac0b23e 100644
--- a/main.c
+++ b/main.c
@@ -4,6 +4,7 @@
 #include "memlayout.h"
 #include "mmu.h"
 #include "proc.h"
+#include "sock.h"
 #include "x86.h"
 
 static void startothers(void);
@@ -27,10 +28,11 @@ main(void)
   consoleinit();   // console hardware
   uartinit();      // serial port
   pinit();         // process table
+  sinit();         // socket table
   tvinit();        // trap vectors
   binit();         // buffer cache
   fileinit();      // file table
-  ideinit();       // disk 
+  ideinit();       // disk
   startothers();   // start other processors
   kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
   userinit();      // first user process
diff --git a/param.h b/param.h
index a7e90ef..f8e5027 100644
--- a/param.h
+++ b/param.h
@@ -1,3 +1,5 @@
+#define NPORT       128  // maximum number of ports
+#define NSOCK        32  // maximum number of sockets
 #define NPROC        64  // maximum number of processes
 #define KSTACKSIZE 4096  // size of per-process kernel stack
 #define NCPU          8  // maximum number of CPUs
diff --git a/patch_xv6_Socket_1505031 b/patch_xv6_Socket_1505031
new file mode 100644
index 0000000..3b8d996
--- /dev/null
+++ b/patch_xv6_Socket_1505031
@@ -0,0 +1,1152 @@
+commit a36121b7a10a6063fc400f01cf4897502a078d7f
+Author: gahab <1505031.zw@ugrad.cse.buet.ac.bd>
+Date:   Thu Jan 17 07:29:58 2019 -0500
+
+    first commit
+
+diff --git a/Makefile b/Makefile
+index 09d790c..e011a93 100644
+--- a/Makefile
++++ b/Makefile
+@@ -16,12 +16,14 @@ OBJS = \
+ 	pipe.o\
+ 	proc.o\
+ 	sleeplock.o\
++	sock.o\
+ 	spinlock.o\
+ 	string.o\
+ 	swtch.o\
+ 	syscall.o\
+ 	sysfile.o\
+ 	sysproc.o\
++	syssock.o\
+ 	trapasm.o\
+ 	trap.o\
+ 	uart.o\
+@@ -181,6 +183,7 @@ UPROGS=\
+ 	_usertests\
+ 	_wc\
+ 	_zombie\
++	_socktest\
+ 
+ fs.img: mkfs README $(UPROGS)
+ 	./mkfs fs.img README $(UPROGS)
+diff --git a/defs.h b/defs.h
+index 82fb982..e88c9fb 100644
+--- a/defs.h
++++ b/defs.h
+@@ -121,6 +121,14 @@ int             wait(void);
+ void            wakeup(void*);
+ void            yield(void);
+ 
++// sock.c
++void            sinit(void);
++int             listen(int);
++int             connect(int, const char*);
++int             send(int, const char*, int);
++int             recv(int, char*, int);
++int             disconnect(int);
++
+ // swtch.S
+ void            swtch(struct context**, struct context*);
+ 
+@@ -188,3 +196,10 @@ void            clearpteu(pde_t *pgdir, char *uva);
+ 
+ // number of elements in fixed-size array
+ #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
++
++//modifed
++#define E_NOTFOUND -1025
++#define E_ACCESS_DENIED -1026
++#define E_WRONG_STATE -1027
++#define E_FAIL -1028
++#define E_INVALID_ARG -1029
+\ No newline at end of file
+diff --git a/main.c b/main.c
+index 9924e64..ac0b23e 100644
+--- a/main.c
++++ b/main.c
+@@ -4,6 +4,7 @@
+ #include "memlayout.h"
+ #include "mmu.h"
+ #include "proc.h"
++#include "sock.h"
+ #include "x86.h"
+ 
+ static void startothers(void);
+@@ -27,10 +28,11 @@ main(void)
+   consoleinit();   // console hardware
+   uartinit();      // serial port
+   pinit();         // process table
++  sinit();         // socket table
+   tvinit();        // trap vectors
+   binit();         // buffer cache
+   fileinit();      // file table
+-  ideinit();       // disk 
++  ideinit();       // disk
+   startothers();   // start other processors
+   kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
+   userinit();      // first user process
+diff --git a/param.h b/param.h
+index a7e90ef..f8e5027 100644
+--- a/param.h
++++ b/param.h
+@@ -1,3 +1,5 @@
++#define NPORT       128  // maximum number of ports
++#define NSOCK        32  // maximum number of sockets
+ #define NPROC        64  // maximum number of processes
+ #define KSTACKSIZE 4096  // size of per-process kernel stack
+ #define NCPU          8  // maximum number of CPUs
+diff --git a/sock.c b/sock.c
+new file mode 100644
+index 0000000..214b61f
+--- /dev/null
++++ b/sock.c
+@@ -0,0 +1,325 @@
++#include "types.h"
++#include "defs.h"
++#include "param.h"
++#include "spinlock.h"
++#include "sock.h"
++#include "memlayout.h"
++#include "mmu.h"
++#include "x86.h"
++#include "proc.h"
++//
++// TODO: Create a structure to maintain a list of sockets
++// Should it have locking?
++//
++
++struct {
++    struct spinlock lock;
++    struct sock sock[NSOCK];
++
++} stable;
++
++//static struct sock *initsock;
++
++void
++sinit(void) {
++    //
++    // TODO: Write any initialization code for socket API
++    // initialization.
++    //
++    initlock(&stable.lock, "stable");
++}
++
++int
++getUnusedSocket(void) {
++
++    struct sock s;
++    for (int i = 0; i < NSOCK; i++) {
++        s = stable.sock[i];
++        if (s.state == CLOSED) return i;
++    }
++    return E_FAIL;
++}
++
++int
++listen(int lport) {
++
++    //
++    // TODO: Put the actual implementation of listen here.
++    //
++    cprintf("In listening method .... port no. %d\n", lport);
++
++    struct sock *s;
++
++    acquire(&stable.lock);
++    cprintf("Iterating over stable\n");
++    for (s = stable.sock; s < &stable.sock[NSOCK]; s++) {
++
++        if ((s->lport == lport || s->rport == lport) && s->state != CLOSED)
++            goto found;
++    }
++    struct sock newsock;
++    newsock.lport = lport;
++    newsock.rport = lport;
++    newsock.state = LISTENING;
++    newsock.owner = myproc()->pid;
++    int iter = getUnusedSocket();
++    stable.sock[iter] = newsock;
++
++    release(&stable.lock);
++    return 0;
++
++found:
++
++    release(&stable.lock);
++    return -1;
++}
++
++int
++isUnused(int port) {
++    struct sock *s;
++    for (s = stable.sock; s < &stable.sock[NSOCK]; s++) {
++        if ((s->lport == port || s->rport == port) && s->state == CLOSED) return 1;
++
++        if ((s->lport == port || s->rport == port) && s->state != CLOSED) return 0;
++
++
++
++    }
++    return 1;
++}
++
++int
++getUnusedPort(void) {
++    //cprintf("in getunusedport()\n");
++    for (int i = 1; i <= NPORT; i++) {
++        if (isUnused(i) == 1) return i;
++
++    }
++    return E_FAIL;
++}
++
++int
++connect(int rport, const char* host) {
++    //
++    // TODO: Put the actual implementation of connect here.
++    //
++    //cprintf("In connect method .... port no. %d\n",rport);
++
++    struct sock *s;
++
++    acquire(&stable.lock);
++    //cprintf("Iterating over stable\n");
++    for (s = stable.sock; s < &stable.sock[NSOCK]; s++) {
++        if (s->lport == rport && s->state == LISTENING)
++
++            goto found;
++
++
++    }
++    release(&stable.lock);
++    return -1;
++found:
++    s->state = CONNECTED;
++    struct sock newsock;
++    newsock.rport = rport;
++    newsock.lport = getUnusedPort(); /// need to change this
++    newsock.state = CONNECTED;
++    newsock.owner = myproc()->pid;
++    int iter = getUnusedSocket();
++    stable.sock[iter] = newsock;
++
++    release(&stable.lock);
++    return newsock.lport;
++}
++
++int
++getRemotePort(int lport) {
++    struct sock *s;
++    //cprintf("Iterating over stable\n");
++    for (s = stable.sock; s < &stable.sock[NSOCK]; s++) {
++        if (s->lport == lport)
++            return s->rport;
++    }
++    return -1;
++}
++
++int
++getOwner(int lport) {
++    struct sock *s;
++    //cprintf("Iterating over stable\n");
++    for (s = stable.sock; s < &stable.sock[NSOCK]; s++) {
++        if (s->lport == lport)
++            return s->owner;
++    }
++    return -1;
++}
++
++int
++send(int lport, const char* data, int n) {
++    //
++    // TODO: Put the actual implementation of send here.
++    //
++    //   cprintf("in send() method:      ->>>>\n");
++    struct sock *s;
++
++    acquire(&stable.lock);
++    int rport = getRemotePort(lport);
++    int owner = getOwner(lport);
++    if (owner != myproc()->pid) return E_ACCESS_DENIED;
++    if (rport == lport) { //then server is sending data 
++        cprintf("server %d is sending data: %s\n", myproc()->pid, data);
++        for (s = stable.sock; s < &stable.sock[NSOCK]; s++) {
++            if (s->rport == lport && s->state == CONNECTED) //client sockets who are connected to this particular server has their remote port equals to server's local port
++
++                goto found1;
++            if (s->rport == lport && s->state != CONNECTED) //client sockets who are connected to this particular server has their remote port equals to server's local port
++
++                return E_WRONG_STATE;
++
++
++        }
++        release(&stable.lock);
++        return -1;
++found1:
++        release(&stable.lock);
++        while (1) {
++
++            acquire(&stable.lock);
++            if (s->isDataPresent == 0) {
++                safestrcpy( s->buffer,data, n);
++                s->isDataPresent = 1;
++                release(&stable.lock);
++                break;
++            }
++            release(&stable.lock);
++        }
++        return 0;
++    } else if (rport != lport) { //client is sending data
++        cprintf("client %d is sending data: %s\n", myproc()->pid, data);
++        for (s = stable.sock; s < &stable.sock[NSOCK]; s++) {
++            if (s->lport == rport && s->state == CONNECTED)
++                goto found0;
++            if (s->lport == rport && s->state != CONNECTED)
++                return E_WRONG_STATE;
++        }
++        release(&stable.lock);
++        return -1;
++found0:
++        //while(s->isDataPresent == 1);
++
++        release(&stable.lock);
++        while (1) {
++
++            acquire(&stable.lock);
++            if (s->isDataPresent == 0) {
++                safestrcpy( s->buffer,data, n);
++                s->isDataPresent = 1;
++                release(&stable.lock);
++                break;
++            }
++            release(&stable.lock);
++        }
++        return 0;
++    }
++    return 0;
++}
++
++int
++recv(int lport, char* data, int n) {
++    //
++    // TODO: Put the actual implementation of recv here.
++    //
++    // TODO: Put the actual implementation of send here.
++    //
++    //  cprintf("in receive() method:      ->>>>\n");
++    struct sock *s;
++
++    acquire(&stable.lock);
++    int rport = getRemotePort(lport);
++    int owner = getOwner(lport);
++    if (owner != myproc()->pid) return E_ACCESS_DENIED;
++    if (rport == lport) { // \\then server is sending data 
++        for (s = stable.sock; s < &stable.sock[NSOCK]; s++) {
++            if (s->rport == lport && s->state == CONNECTED) //client sockets who are connected to this particular server has their remote port equals to server's local port
++
++                goto found1;
++            if (s->rport == lport && s->state != CONNECTED)
++                return E_WRONG_STATE;
++
++
++        }
++        release(&stable.lock);
++
++        return -1;
++found1:
++        //while(s->isDataPresent == 0);
++
++        release(&stable.lock);
++        while (1) {
++
++            acquire(&stable.lock);
++            if (s->isDataPresent == 1) {
++                safestrcpy(data, s->buffer, n);
++                s->isDataPresent = 0;
++                release(&stable.lock);
++                break;
++            }
++            release(&stable.lock);
++        }
++        return 0;
++    } else if (rport != lport) { //client is receiving data
++        for (s = stable.sock; s < &stable.sock[NSOCK]; s++) {
++            if (s->lport == rport && s->state == CONNECTED)
++
++                goto found0;
++            if (s->lport == rport && s->state != CONNECTED)
++                return E_WRONG_STATE;
++
++
++        }
++        release(&stable.lock);
++        return -1;
++found0:
++        release(&stable.lock);
++        while (1) {
++
++            acquire(&stable.lock);
++            if (s->isDataPresent == 1) {
++                safestrcpy(data, s->buffer, n);
++                s->isDataPresent = 0;
++                release(&stable.lock);
++                break;
++            }
++            release(&stable.lock);
++        }
++
++
++
++        return 0;
++    }
++    return 0;
++}
++
++int
++disconnect(int lport) {
++    //
++    // TODO: Put the actual implementation of disconnect here.
++    //
++    struct sock *s;
++
++    acquire(&stable.lock);
++    //cprintf("Iterating over stable\n");
++    for (s = stable.sock; s < &stable.sock[NSOCK]; s++) {
++        if (s->lport == lport && s->state != CLOSED && s->owner == myproc()->pid) {
++            s->state = CLOSED;
++            release(&stable.lock);
++            return 0;
++        }
++        if (s->lport == lport && s->state != CLOSED && s->owner != myproc()->pid) {
++            release(&stable.lock);
++            return E_ACCESS_DENIED;
++        }
++    }
++    release(&stable.lock);
++    return 0;
++}
+diff --git a/sock.h b/sock.h
+new file mode 100644
+index 0000000..da6ba9f
+--- /dev/null
++++ b/sock.h
+@@ -0,0 +1,20 @@
++
++//
++// TODO: Define an enumeration to represent socket state.
++//
++
++
++enum sockstate { CLOSED, CONNECTED, LISTENING }; //CLOSED --> NOT IN USE // CONNECTED -> CURRENTLY IN USE // AVAILABE-> WANTS TO CONNECT
++
++//
++// TODO: Define a structure to represent a socket.
++//
++
++struct sock {
++    int lport;
++    int rport;
++    enum sockstate state;
++    int owner; 
++     char buffer[128]; 
++     int isDataPresent;
++};
+\ No newline at end of file
+diff --git a/socktest.c b/socktest.c
+new file mode 100644
+index 0000000..a53cdc9
+--- /dev/null
++++ b/socktest.c
+@@ -0,0 +1,80 @@
++#include "types.h"
++#include "user.h"
++
++int serverPort = 10;
++
++void clientProc() {
++       printf(1,"PID OF CLIENT PROCEDURE: %d\n",getpid());
++  int clientPort;
++  char buf[128];
++  char host[16] = "localhost";
++
++  // sleep for 100 clock ticks to ensure that the server process starts first.
++  sleep(100);
++
++  printf(1, "Client>> Attempting to connect to port %d, host %s ...\n", serverPort, host);
++  clientPort = connect(serverPort, host);
++  sleep(20);
++  printf(1, "Client>> connect() returned %d\n", clientPort);
++
++  while (1) {
++    printf(1, "Client>> Enter text to send to server: ");
++    gets(buf, sizeof(buf));
++    sleep(20);
++    buf[strlen(buf) - 1] = '\0'; // Eliminating the '\n'
++    send(clientPort, buf, strlen(buf) + 1);
++
++    if (0 == strcmp(buf, "exit")) {
++      printf(1, "Client exiting...\n");
++      disconnect(clientPort);
++      break;
++    }
++
++    sleep(100 + uptime() % 100);
++
++    recv(clientPort, buf, sizeof(buf));
++    printf(1, "Client>> Received: \"%s\"\n", buf);
++  }
++}
++
++void serverProc() {
++    printf(1,"PID OF SERVER PROCEDURE: %d\n",getpid());
++  int status;
++  char buf[128];
++
++  printf(1, "Server>> Starting to listen at port %d ...\n", serverPort);
++  status = listen(serverPort);
++  printf(1, "Server>> listen() returned %d\n", status);
++
++  while (1) {
++    sleep(100 + uptime() % 100);
++
++    recv(serverPort, buf, sizeof(buf));
++    printf(1, "Server>> Received: \"%s\"\n", buf);
++
++    if (0 == strcmp(buf, "exit")) {
++      printf(1, "Server exiting...\n");
++      disconnect(serverPort);
++      break;
++    }
++
++    sleep(100 + uptime() % 100);
++
++    strcpy(buf+strlen(buf), " OK");
++    send(serverPort, buf, strlen(buf) + 1);
++  }
++}
++
++
++int main(int argc, char *argv[])
++{
++  if (0 == fork()) {
++    clientProc();
++    exit();
++  } else {
++    serverProc();
++    // This is the parent process. So, it needs to wait before client terminates
++    wait();
++    exit();
++  }
++}
+diff --git a/syscall.c b/syscall.c
+index ee85261..c06bb58 100644
+--- a/syscall.c
++++ b/syscall.c
+@@ -60,7 +60,7 @@ argptr(int n, char **pp, int size)
+ {
+   int i;
+   struct proc *curproc = myproc();
+- 
++
+   if(argint(n, &i) < 0)
+     return -1;
+   if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz)
+@@ -103,6 +103,11 @@ extern int sys_unlink(void);
+ extern int sys_wait(void);
+ extern int sys_write(void);
+ extern int sys_uptime(void);
++extern int sys_listen(void);
++extern int sys_connect(void);
++extern int sys_send(void);
++extern int sys_recv(void);
++extern int sys_disconnect(void);
+ 
+ static int (*syscalls[])(void) = {
+ [SYS_fork]    sys_fork,
+@@ -126,6 +131,11 @@ static int (*syscalls[])(void) = {
+ [SYS_link]    sys_link,
+ [SYS_mkdir]   sys_mkdir,
+ [SYS_close]   sys_close,
++[SYS_listen]  sys_listen,
++[SYS_connect] sys_connect,
++[SYS_send]    sys_send,
++[SYS_recv]    sys_recv,
++[SYS_disconnect] sys_disconnect
+ };
+ 
+ void
+diff --git a/syscall.h b/syscall.h
+index bc5f356..289fb4b 100644
+--- a/syscall.h
++++ b/syscall.h
+@@ -20,3 +20,8 @@
+ #define SYS_link   19
+ #define SYS_mkdir  20
+ #define SYS_close  21
++#define SYS_listen  22
++#define SYS_connect  23
++#define SYS_send  24
++#define SYS_recv  25
++#define SYS_disconnect  26
+diff --git a/syssock.c b/syssock.c
+new file mode 100644
+index 0000000..0a659af
+--- /dev/null
++++ b/syssock.c
+@@ -0,0 +1,86 @@
++#include "types.h"
++#include "defs.h"
++#include "param.h"
++#include "memlayout.h"
++#include "mmu.h"
++#include "x86.h"
++#include "proc.h"
++
++int
++sys_listen(void) {
++    int port;
++    if (argint(0, &port) < 0)
++        return -1;
++    if (port < 1 || port >= NPORT) return E_INVALID_ARG;
++
++    return listen(port);
++}
++
++int
++sys_connect(void) {
++    //  cprintf("in sys_connect()");
++
++    int port;
++    char *host;
++    if (argint(0, &port) < 0) return -1;
++    if (port < 1 || port >= NPORT) return E_INVALID_ARG;
++    argstr(1, &host);
++    if (argstr(1, &host) < 0) return -1;
++
++    int len1 = strlen(host);
++    int len2 = strlen("localhost");
++    int len3 = strlen("127.0.0.1");
++    if ((len1 == len2 && strncmp(host, "localhost", len1) == 0) || (len1 == len3 && strncmp(host, "127.0.0.1", len1) == 0)) {
++        //valid
++    } else return E_INVALID_ARG;
++    cprintf("port : %d   host: %s", port, host);
++
++
++    return connect(port, host);
++}
++
++int
++sys_send(void) {
++    int port;
++    char* buf;
++    int n;
++    argint(0, &port);
++    argstr(1, &buf);
++    argint(2, &n);
++    //    if (argint(0, &port) < 0 && argstr(1, &buf) != 1 && argint(2, &n) != -1)
++    //        return -1;
++    //
++    // TODO: Write your code to get and validate port no., buffer and buffer size
++    //
++
++    return send(port, buf, n);
++}
++
++int
++sys_recv(void) {
++
++    int port;
++    char* buf;
++    int n;
++    argint(0, &port);
++    argstr(1, &buf);
++    argint(2, &n);
++    //    if (argint(0, &port) < 0 && argstr(1, &buf) != 1 && argint(2, &n) != -1)
++    //        return -1;
++    //
++    // TODO: Write your code to get and validate port no., buffer and buffer size
++    //
++
++    return recv(port, buf, n);
++}
++
++int
++sys_disconnect(void) {
++    int port = 0;
++
++    //
++    // TODO: Write your code to get and validate port no.
++    //
++
++    return disconnect(port);
++}
+diff --git a/user.h b/user.h
+index 4f99c52..55ebf5c 100644
+--- a/user.h
++++ b/user.h
+@@ -23,6 +23,11 @@ int getpid(void);
+ char* sbrk(int);
+ int sleep(int);
+ int uptime(void);
++int listen(int);
++int connect(int, const char* host);
++int send(int, const char*, int);
++int recv(int, char*, int);
++int disconnect(int);
+ 
+ // ulib.c
+ int stat(const char*, struct stat*);
+@@ -37,3 +42,11 @@ void* memset(void*, int, uint);
+ void* malloc(uint);
+ void free(void*);
+ int atoi(const char*);
++
++
++//modifed
++#define E_NOTFOUND -1025
++#define E_ACCESS_DENIED -1026
++#define E_WRONG_STATE -1027
++#define E_FAIL -1028
++#define E_INVALID_ARG -1029
+diff --git a/usys.S b/usys.S
+index 8bfd8a1..2ac5ed0 100644
+--- a/usys.S
++++ b/usys.S
+@@ -29,3 +29,9 @@ SYSCALL(getpid)
+ SYSCALL(sbrk)
+ SYSCALL(sleep)
+ SYSCALL(uptime)
++SYSCALL(listen)
++SYSCALL(connect)
++SYSCALL(send)
++SYSCALL(recv)
++SYSCALL(disconnect)
++
+diff --git a/xv6_SocketStub_patch b/xv6_SocketStub_patch
+new file mode 100644
+index 0000000..aebc3cd
+--- /dev/null
++++ b/xv6_SocketStub_patch
+@@ -0,0 +1,419 @@
++commit 02195eee285ee63f3aae983a85a6fdaec47fafd6
++Author: Saifur Rahman <saifur80@gmail.com>
++Date:   Sun Jan 13 22:07:13 2019 +0600
++
++    xv6 Socket API stub for students
++
++diff --git a/Makefile b/Makefile
++index 09d790c..e011a93 100644
++--- a/Makefile
+++++ b/Makefile
++@@ -16,12 +16,14 @@ OBJS = \
++ 	pipe.o\
++ 	proc.o\
++ 	sleeplock.o\
+++	sock.o\
++ 	spinlock.o\
++ 	string.o\
++ 	swtch.o\
++ 	syscall.o\
++ 	sysfile.o\
++ 	sysproc.o\
+++	syssock.o\
++ 	trapasm.o\
++ 	trap.o\
++ 	uart.o\
++@@ -181,6 +183,7 @@ UPROGS=\
++ 	_usertests\
++ 	_wc\
++ 	_zombie\
+++	_socktest\
++ 
++ fs.img: mkfs README $(UPROGS)
++ 	./mkfs fs.img README $(UPROGS)
++diff --git a/defs.h b/defs.h
++index 82fb982..ae6ae7e 100644
++--- a/defs.h
+++++ b/defs.h
++@@ -121,6 +121,14 @@ int             wait(void);
++ void            wakeup(void*);
++ void            yield(void);
++ 
+++// sock.c
+++void            sinit(void);
+++int             listen(int);
+++int             connect(int, const char*);
+++int             send(int, const char*, int);
+++int             recv(int, char*, int);
+++int             disconnect(int);
+++
++ // swtch.S
++ void            swtch(struct context**, struct context*);
++ 
++diff --git a/main.c b/main.c
++index 9924e64..ac0b23e 100644
++--- a/main.c
+++++ b/main.c
++@@ -4,6 +4,7 @@
++ #include "memlayout.h"
++ #include "mmu.h"
++ #include "proc.h"
+++#include "sock.h"
++ #include "x86.h"
++ 
++ static void startothers(void);
++@@ -27,10 +28,11 @@ main(void)
++   consoleinit();   // console hardware
++   uartinit();      // serial port
++   pinit();         // process table
+++  sinit();         // socket table
++   tvinit();        // trap vectors
++   binit();         // buffer cache
++   fileinit();      // file table
++-  ideinit();       // disk 
+++  ideinit();       // disk
++   startothers();   // start other processors
++   kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
++   userinit();      // first user process
++diff --git a/param.h b/param.h
++index a7e90ef..f8e5027 100644
++--- a/param.h
+++++ b/param.h
++@@ -1,3 +1,5 @@
+++#define NPORT       128  // maximum number of ports
+++#define NSOCK        32  // maximum number of sockets
++ #define NPROC        64  // maximum number of processes
++ #define KSTACKSIZE 4096  // size of per-process kernel stack
++ #define NCPU          8  // maximum number of CPUs
++diff --git a/sock.c b/sock.c
++new file mode 100644
++index 0000000..4d92581
++--- /dev/null
+++++ b/sock.c
++@@ -0,0 +1,70 @@
+++#include "types.h"
+++#include "defs.h"
+++#include "param.h"
+++#include "spinlock.h"
+++#include "sock.h"
+++#include "memlayout.h"
+++#include "mmu.h"
+++#include "x86.h"
+++#include "proc.h"
+++
+++//
+++// TODO: Create a structure to maintain a list of sockets
+++// Should it have locking?
+++//
+++
+++void
+++sinit(void)
+++{
+++  //
+++  // TODO: Write any initialization code for socket API
+++  // initialization.
+++  //
+++}
+++
+++int
+++listen(int lport) {
+++
+++  //
+++  // TODO: Put the actual implementation of listen here.
+++  //
+++
+++  return 0;
+++}
+++
+++int
+++connect(int rport, const char* host) {
+++  //
+++  // TODO: Put the actual implementation of connect here.
+++  //
+++
+++  return 0;
+++}
+++
+++int
+++send(int lport, const char* data, int n) {
+++  //
+++  // TODO: Put the actual implementation of send here.
+++  //
+++
+++  return 0;
+++}
+++
+++
+++int
+++recv(int lport, char* data, int n) {
+++  //
+++  // TODO: Put the actual implementation of recv here.
+++  //
+++
+++  return 0;
+++}
+++
+++int
+++disconnect(int lport) {
+++  //
+++  // TODO: Put the actual implementation of disconnect here.
+++  //
+++
+++  return 0;
+++}
++diff --git a/sock.h b/sock.h
++new file mode 100644
++index 0000000..2ab24fe
++--- /dev/null
+++++ b/sock.h
++@@ -0,0 +1,8 @@
+++
+++//
+++// TODO: Define an enumeration to represent socket state.
+++//
+++
+++//
+++// TODO: Define a structure to represent a socket.
+++//
++diff --git a/socktest.c b/socktest.c
++new file mode 100644
++index 0000000..b68a705
++--- /dev/null
+++++ b/socktest.c
++@@ -0,0 +1,77 @@
+++#include "types.h"
+++#include "user.h"
+++
+++int serverPort = 10;
+++
+++void clientProc() {
+++  int clientPort;
+++  char buf[128];
+++  char host[16] = "localhost";
+++
+++  // sleep for 100 clock ticks to ensure that the server process starts first.
+++  sleep(100);
+++
+++  printf(1, "Client>> Attempting to connect to port %d, host %s ...\n", serverPort, host);
+++  clientPort = connect(serverPort, host);
+++  sleep(20);
+++  printf(1, "Client>> connect() returned %d\n", clientPort);
+++
+++  while (1) {
+++    printf(1, "Client>> Enter text to send to server: ");
+++    gets(buf, sizeof(buf));
+++    buf[strlen(buf) - 1] = '\0'; // Eliminating the '\n'
+++    send(clientPort, buf, strlen(buf) + 1);
+++
+++    if (0 == strcmp(buf, "exit")) {
+++      printf(1, "Client exiting...\n");
+++      disconnect(clientPort);
+++      break;
+++    }
+++
+++    sleep(100 + uptime() % 100);
+++
+++    recv(clientPort, buf, sizeof(buf));
+++    printf(1, "Client>> Received: \"%s\"\n", buf);
+++  }
+++}
+++
+++void serverProc() {
+++  int status;
+++  char buf[128];
+++
+++  printf(1, "Server>> Starting to listen at port %d ...\n", serverPort);
+++  status = listen(serverPort);
+++  printf(1, "Server>> listen() returned %d\n", status);
+++
+++  while (1) {
+++    sleep(100 + uptime() % 100);
+++
+++    recv(serverPort, buf, sizeof(buf));
+++    printf(1, "Server>> Received: \"%s\"\n", buf);
+++
+++    if (0 == strcmp(buf, "exit")) {
+++      printf(1, "Server exiting...\n");
+++      disconnect(serverPort);
+++      break;
+++    }
+++
+++    sleep(100 + uptime() % 100);
+++
+++    strcpy(buf+strlen(buf), " OK");
+++    send(serverPort, buf, strlen(buf) + 1);
+++  }
+++}
+++
+++
+++int main(int argc, char *argv[])
+++{
+++  if (0 == fork()) {
+++    clientProc();
+++    exit();
+++  } else {
+++    serverProc();
+++    // This is the parent process. So, it needs to wait before client terminates
+++    wait();
+++    exit();
+++  }
+++}
++diff --git a/syscall.c b/syscall.c
++index ee85261..c06bb58 100644
++--- a/syscall.c
+++++ b/syscall.c
++@@ -60,7 +60,7 @@ argptr(int n, char **pp, int size)
++ {
++   int i;
++   struct proc *curproc = myproc();
++- 
+++
++   if(argint(n, &i) < 0)
++     return -1;
++   if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz)
++@@ -103,6 +103,11 @@ extern int sys_unlink(void);
++ extern int sys_wait(void);
++ extern int sys_write(void);
++ extern int sys_uptime(void);
+++extern int sys_listen(void);
+++extern int sys_connect(void);
+++extern int sys_send(void);
+++extern int sys_recv(void);
+++extern int sys_disconnect(void);
++ 
++ static int (*syscalls[])(void) = {
++ [SYS_fork]    sys_fork,
++@@ -126,6 +131,11 @@ static int (*syscalls[])(void) = {
++ [SYS_link]    sys_link,
++ [SYS_mkdir]   sys_mkdir,
++ [SYS_close]   sys_close,
+++[SYS_listen]  sys_listen,
+++[SYS_connect] sys_connect,
+++[SYS_send]    sys_send,
+++[SYS_recv]    sys_recv,
+++[SYS_disconnect] sys_disconnect
++ };
++ 
++ void
++diff --git a/syscall.h b/syscall.h
++index bc5f356..289fb4b 100644
++--- a/syscall.h
+++++ b/syscall.h
++@@ -20,3 +20,8 @@
++ #define SYS_link   19
++ #define SYS_mkdir  20
++ #define SYS_close  21
+++#define SYS_listen  22
+++#define SYS_connect  23
+++#define SYS_send  24
+++#define SYS_recv  25
+++#define SYS_disconnect  26
++diff --git a/syssock.c b/syssock.c
++new file mode 100644
++index 0000000..4c006af
++--- /dev/null
+++++ b/syssock.c
++@@ -0,0 +1,73 @@
+++#include "types.h"
+++#include "defs.h"
+++#include "param.h"
+++#include "memlayout.h"
+++#include "mmu.h"
+++#include "x86.h"
+++#include "proc.h"
+++
+++int
+++sys_listen(void)
+++{
+++  int port = 0;
+++
+++  //
+++  // TODO: Write your code to get and validate port no.
+++  //
+++
+++  return listen(port);
+++}
+++
+++int
+++sys_connect(void)
+++{
+++  int port = 0;
+++  char *host = 0;
+++
+++  //
+++  // TODO: Write your code to get and validate port no., host.
+++  // Allow connection to "localhost" or "127.0.0.1" host only
+++  //
+++
+++  return connect(port, host);
+++}
+++
+++int
+++sys_send(void)
+++{
+++  int port = 0;
+++  char* buf = 0;
+++  int n = 0;
+++
+++  //
+++  // TODO: Write your code to get and validate port no., buffer and buffer size
+++  //
+++
+++  return send(port, buf, n);
+++}
+++
+++int
+++sys_recv(void)
+++{
+++  int port = 0;
+++  char* buf = 0;
+++  int n = 0;
+++
+++  //
+++  // TODO: Write your code to get and validate port no., buffer and buffer size
+++  //
+++
+++  return recv(port, buf, n);
+++}
+++
+++int
+++sys_disconnect(void)
+++{
+++  int port = 0;
+++
+++  //
+++  // TODO: Write your code to get and validate port no.
+++  //
+++
+++  return disconnect(port);
+++}
++diff --git a/user.h b/user.h
++index 4f99c52..ce9f2f1 100644
++--- a/user.h
+++++ b/user.h
++@@ -23,6 +23,11 @@ int getpid(void);
++ char* sbrk(int);
++ int sleep(int);
++ int uptime(void);
+++int listen(int);
+++int connect(int, const char* host);
+++int send(int, const char*, int);
+++int recv(int, char*, int);
+++int disconnect(int);
++ 
++ // ulib.c
++ int stat(const char*, struct stat*);
++diff --git a/usys.S b/usys.S
++index 8bfd8a1..2ac5ed0 100644
++--- a/usys.S
+++++ b/usys.S
++@@ -29,3 +29,9 @@ SYSCALL(getpid)
++ SYSCALL(sbrk)
++ SYSCALL(sleep)
++ SYSCALL(uptime)
+++SYSCALL(listen)
+++SYSCALL(connect)
+++SYSCALL(send)
+++SYSCALL(recv)
+++SYSCALL(disconnect)
+++
diff --git a/sock.c b/sock.c
new file mode 100644
index 0000000..4ef2908
--- /dev/null
+++ b/sock.c
@@ -0,0 +1,337 @@
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "spinlock.h"
+#include "sock.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "x86.h"
+#include "proc.h"
+//
+// TODO: Create a structure to maintain a list of sockets
+// Should it have locking?
+//
+
+struct {
+    struct spinlock lock;
+    struct sock sock[NSOCK];
+
+} stable;
+
+//static struct sock *initsock;
+
+void
+sinit(void) {
+    //
+    // TODO: Write any initialization code for socket API
+    // initialization.
+    //
+    initlock(&stable.lock, "stable");
+}
+
+int
+getUnusedSocket(void) {
+
+    struct sock *s;
+    for (int i = 0; i < NSOCK; i++) {
+        s = &stable.sock[i];
+        if (s->state == CLOSED) return i;
+    }
+    return E_FAIL;
+
+    //cprintf("Iterating over stable\n");
+
+}
+
+int
+listen(int lport) {
+
+    //
+    // TODO: Put the actual implementation of listen here.
+    //
+
+
+    struct sock *s;
+
+    acquire(&stable.lock);
+   
+    for (s = stable.sock; s < &stable.sock[NSOCK]; s++) {
+       
+        if ((s->lport == lport || s->rport == lport) && s->state != CLOSED)
+            goto found;
+    }
+
+    int iter = getUnusedSocket();
+    stable.sock[iter].lport = lport;
+    stable.sock[iter].rport = 0;
+
+    stable.sock[iter].state = LISTENING;
+    stable.sock[iter].owner = myproc()->pid;
+    ;
+
+    struct sock *newSockPtr; //= (struct*)stable.sock[iter];
+    for (newSockPtr = stable.sock; newSockPtr < &stable.sock[NSOCK]; newSockPtr++) {
+
+        if (newSockPtr->lport == lport)//
+            break; //|| s->rport == lport) && s->state != CLOSED)
+        //  goto found;
+    }
+    sleep(newSockPtr, &stable.lock);
+    release(&stable.lock);
+    return 0;
+
+found:
+
+    release(&stable.lock);
+    return E_WRONG_STATE;
+}
+
+int
+isUnused(int port) {
+    struct sock *s;
+   // cprintf("in unused for %d\n", port);
+    for (s = stable.sock; s < &stable.sock[NSOCK]; s++) {
+      
+        if (s->lport == port && s->state == CLOSED) return 1;
+        if (s->rport == port && s->state == CLOSED) return 1;
+        if (s->rport == port && s->state != CLOSED) return 0;
+        if (s->lport == port && s->state != CLOSED) return 0;
+
+
+    }
+    return 1;
+}
+
+int
+getUnusedPort(void) {
+    // cprintf("in getunusedport()\n");
+    for (int i = 1; i <= NPORT; i++) {
+        
+        if (isUnused(i) == 1) return i;
+
+    }
+    return E_FAIL;
+}
+
+int
+connect(int rport, const char* host) {
+    //
+    // TODO: Put the actual implementation of connect here.
+    //
+    ////cprintf("In connect method .... port no. %d\n",rport);
+
+    struct sock *s;
+
+    acquire(&stable.lock);
+  
+    for (s = stable.sock; s < &stable.sock[NSOCK]; s++) {
+       
+        if (s->lport == rport && s->state == LISTENING)
+
+            goto found;
+        if (s->lport == rport && s->state != LISTENING)
+
+            goto found1;
+
+
+    }
+    release(&stable.lock);
+    return E_NOTFOUND;
+found1:
+    release(&stable.lock);
+    return E_WRONG_STATE;
+
+found:
+    s->state = CONNECTED;
+
+
+
+    int x = getUnusedPort(); /// need to change this
+    s->rport = x;
+
+    int iter = getUnusedSocket();
+    stable.sock[iter].lport = x;
+    stable.sock[iter].rport = rport;
+    stable.sock[iter].state = CONNECTED;
+    stable.sock[iter].owner = myproc()->pid;
+    wakeup(s);
+    release(&stable.lock);
+    return x;
+}
+
+int
+getRemotePort(int lport) {
+    struct sock *s;
+    ////cprintf("Iterating over stable\n");
+    for (s = stable.sock; s < &stable.sock[NSOCK]; s++) {
+        if (s->lport == lport)
+            return s->rport;
+    }
+    return -1;
+}
+
+int
+getOwner(int lport) {
+    struct sock *s;
+    ////cprintf("Iterating over stable\n");
+    for (s = stable.sock; s < &stable.sock[NSOCK]; s++) {
+        if (s->lport == lport)
+            return s->owner;
+    }
+    return -1;
+}
+
+int
+isPresent(int lport) {
+    struct sock *s;
+    ////cprintf("Iterating over stable\n");
+    for (s = stable.sock; s < &stable.sock[NSOCK]; s++) {
+        if (s->lport == lport)
+            return 0;
+    }
+    return E_NOTFOUND;
+}
+
+int
+send(int lport, const char* data, int n) {
+    //
+    // TODO: Put the actual implementation of send here.
+    //
+    //   //cprintf("in send() method:      ->>>>\n");
+    struct sock *s;
+
+    acquire(&stable.lock);
+    if (isPresent(lport) == E_NOTFOUND) {
+        release(&stable.lock);
+        return E_NOTFOUND;
+    }
+    int rport = getRemotePort(lport);
+    int owner = getOwner(lport);
+    if (owner != myproc()->pid) {
+        release(&stable.lock);
+        return E_ACCESS_DENIED;
+    }
+    struct sock *localsock;
+    for (localsock = stable.sock; localsock < &stable.sock[NSOCK]; localsock++) {
+        if (localsock->lport == lport)
+            break;
+    }
+
+    //client is sending data
+    //cprintf("client %d is sending data: %s\n", myproc()->pid, data);
+    for (s = stable.sock; s < &stable.sock[NSOCK]; s++) {
+        if (s->lport == rport && s->state == CONNECTED)
+            goto found0;
+        if (s->lport == rport && s->state != CONNECTED) {
+            release(&stable.lock);
+            return E_WRONG_STATE;
+        }
+
+    }
+    release(&stable.lock);
+    return E_WRONG_STATE;
+found0:
+
+    if (s->isDataPresent == 1) {
+        //  release(&stable.lock);
+        sleep(s, &stable.lock);
+    }
+    // acquire(&stable.lock);
+    safestrcpy(s->buffer, data, n);
+    s->isDataPresent = 1;
+
+    wakeup(localsock);
+    release(&stable.lock);
+
+
+
+
+    return 0;
+}
+
+int
+recv(int lport, char* data, int n) {
+    //
+    // TODO: Put the actual implementation of recv here.
+    //
+    // TODO: Put the actual implementation of send here.
+    //
+    //  //cprintf("in receive() method:      ->>>>\n");
+    struct sock *s;
+
+    acquire(&stable.lock);
+    if (isPresent(lport) == E_NOTFOUND) {
+        release(&stable.lock);
+        return E_NOTFOUND;
+    }
+    int rport = getRemotePort(lport);
+    int owner = getOwner(lport);
+    if (owner != myproc()->pid) {
+        release(&stable.lock);
+        return E_ACCESS_DENIED;
+    }
+    struct sock *localsock;
+    for (localsock = stable.sock; localsock < &stable.sock[NSOCK]; localsock++) {
+        if (localsock->lport == lport)
+            break;
+    }
+
+    for (s = stable.sock; s < &stable.sock[NSOCK]; s++) {
+        if (s->lport == rport)
+
+            goto found0;
+
+
+
+
+    }
+    release(&stable.lock);
+    return E_NOTFOUND;
+found0:
+    // cprintf("client receiving data %s\n",data);
+    if (localsock->isDataPresent == 0) {
+        //  release(&stable.lock);
+        sleep(s, &stable.lock);
+    }
+    // acquire(&stable.lock);
+    safestrcpy(data, localsock->buffer, n);
+    localsock->isDataPresent = 0;
+
+    wakeup(localsock);
+    release(&stable.lock);
+
+
+    return 0;
+
+}
+
+int
+disconnect(int lport) {
+    //
+    // TODO: Put the actual implementation of disconnect here.
+    //
+    struct sock *s;
+
+    acquire(&stable.lock);
+    if (isPresent(lport) == E_NOTFOUND) {
+        release(&stable.lock);
+        return E_NOTFOUND;
+    }
+    //  cprintf("%d is closing its sock of %d\n",myproc()->pid,lport);
+    ////cprintf("Iterating over stable\n");
+    for (s = stable.sock; s < &stable.sock[NSOCK]; s++) {
+        if (s->lport == lport && s->state != CLOSED && s->owner == myproc()->pid) {
+            cprintf("%d is closing its sock of %d,%d\n", myproc()->pid, s->lport, s->rport);
+            s->state = CLOSED;
+            if (s->state == CLOSED) cprintf("done closing\n");
+            release(&stable.lock);
+            return 0;
+        }
+        if (s->lport == lport && s->state != CLOSED && s->owner != myproc()->pid) {
+            release(&stable.lock);
+            return E_ACCESS_DENIED;
+        }
+    }
+    release(&stable.lock);
+    return 0;
+}
diff --git a/sock.h b/sock.h
new file mode 100644
index 0000000..da6ba9f
--- /dev/null
+++ b/sock.h
@@ -0,0 +1,20 @@
+
+//
+// TODO: Define an enumeration to represent socket state.
+//
+
+
+enum sockstate { CLOSED, CONNECTED, LISTENING }; //CLOSED --> NOT IN USE // CONNECTED -> CURRENTLY IN USE // AVAILABE-> WANTS TO CONNECT
+
+//
+// TODO: Define a structure to represent a socket.
+//
+
+struct sock {
+    int lport;
+    int rport;
+    enum sockstate state;
+    int owner; 
+     char buffer[128]; 
+     int isDataPresent;
+};
\ No newline at end of file
diff --git a/socktest.c b/socktest.c
new file mode 100644
index 0000000..2bc3fb8
--- /dev/null
+++ b/socktest.c
@@ -0,0 +1,80 @@
+#include "types.h"
+#include "user.h"
+
+int serverPort = 10;
+
+void clientProc() {
+      // printf(1,"PID OF CLIENT PROCEDURE: %d\n",getpid());
+  int clientPort;
+  char buf[128];
+  char host[16] = "localhost";
+
+  // sleep for 100 clock ticks to ensure that the server process starts first.
+  sleep(100);
+
+  printf(1, "Client>> Attempting to connect to port %d, host %s ...\n", serverPort, host);
+  clientPort = connect(serverPort, host);
+  sleep(20);
+  printf(1, "Client>> connect() returned %d\n", clientPort);
+
+  while (1) {
+    printf(1, "Client>> Enter text to send to server: ");
+    gets(buf, sizeof(buf));
+    sleep(20);
+    buf[strlen(buf) - 1] = '\0'; // Eliminating the '\n'
+    send(clientPort, buf, strlen(buf) + 1);
+
+    if (0 == strcmp(buf, "exit")) {
+      printf(1, "Client exiting...\n");
+      disconnect(clientPort);
+      break;
+    }
+
+    sleep(100 + uptime() % 100);
+
+    recv(clientPort, buf, sizeof(buf));
+    printf(1, "Client>> Received: \"%s\"\n", buf);
+  }
+}
+
+void serverProc() {
+    //printf(1,"PID OF SERVER PROCEDURE: %d\n",getpid());
+  int status;
+  char buf[128];
+
+  printf(1, "Server>> Starting to listen at port %d ...\n", serverPort);
+  status = listen(serverPort);
+  printf(1, "Server>> listen() returned %d\n", status);
+
+  while (1) {
+    sleep(100 + uptime() % 100);
+
+    recv(serverPort, buf, sizeof(buf));
+    printf(1, "Server>> Received: \"%s\"\n", buf);
+
+    if (0 == strcmp(buf, "exit")) {
+      printf(1, "Server exiting...\n");
+      disconnect(serverPort);
+      break;
+    }
+
+    sleep(100 + uptime() % 100);
+
+    strcpy(buf+strlen(buf), " OK");
+    send(serverPort, buf, strlen(buf) + 1);
+  }
+}
+
+
+int main(int argc, char *argv[])
+{
+  if (0 == fork()) {
+    clientProc();
+    exit();
+  } else {
+    serverProc();
+    // This is the parent process. So, it needs to wait before client terminates
+    wait();
+    exit();
+  }
+}
diff --git a/syscall.c b/syscall.c
index ee85261..c06bb58 100644
--- a/syscall.c
+++ b/syscall.c
@@ -60,7 +60,7 @@ argptr(int n, char **pp, int size)
 {
   int i;
   struct proc *curproc = myproc();
- 
+
   if(argint(n, &i) < 0)
     return -1;
   if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz)
@@ -103,6 +103,11 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_listen(void);
+extern int sys_connect(void);
+extern int sys_send(void);
+extern int sys_recv(void);
+extern int sys_disconnect(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -126,6 +131,11 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_listen]  sys_listen,
+[SYS_connect] sys_connect,
+[SYS_send]    sys_send,
+[SYS_recv]    sys_recv,
+[SYS_disconnect] sys_disconnect
 };
 
 void
diff --git a/syscall.h b/syscall.h
index bc5f356..289fb4b 100644
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,8 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_listen  22
+#define SYS_connect  23
+#define SYS_send  24
+#define SYS_recv  25
+#define SYS_disconnect  26
diff --git a/syssock.c b/syssock.c
new file mode 100644
index 0000000..5bf8a8e
--- /dev/null
+++ b/syssock.c
@@ -0,0 +1,92 @@
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "x86.h"
+#include "proc.h"
+
+int
+sys_listen(void) {
+    int port;
+    if (argint(0, &port) < 0)
+        return -1;
+    if (port < 1 || port >= NPORT) return E_INVALID_ARG;
+
+    return listen(port);
+}
+
+int
+sys_connect(void) {
+    //  cprintf("in sys_connect()");
+
+    int port;
+    char *host;
+    if (argint(0, &port) < 0) return -1;
+    if (port < 1 || port >= NPORT) return E_INVALID_ARG;
+    argstr(1, &host);
+    if (argstr(1, &host) < 0) return -1;
+
+    int len1 = strlen(host);
+    int len2 = strlen("localhost");
+    int len3 = strlen("127.0.0.1");
+    if ((len1 == len2 && strncmp(host, "localhost", len1) == 0) || (len1 == len3 && strncmp(host, "127.0.0.1", len1) == 0)) {
+        //valid
+    } else return E_INVALID_ARG;
+   // cprintf("port : %d   host: %s", port, host);
+
+
+    return connect(port, host);
+}
+
+int
+sys_send(void) {
+    int port;
+    char* buf;
+    int n;
+    if (argint(0, &port) < 0) return -1;
+    if (port < 1 || port >= NPORT) return E_INVALID_ARG;
+    argstr(1, &buf);
+    if (argstr(1, &buf) < 0) return -1;
+    if (argint(2, &n) < 0) return -1;
+    //    if (argint(0, &port) < 0 && argstr(1, &buf) != 1 && argint(2, &n) != -1)
+    //        return -1;
+    //
+    // TODO: Write your code to get and validate port no., buffer and buffer size
+    //
+
+    return send(port, buf, n);
+}
+
+int
+sys_recv(void) {
+
+    int port;
+    char* buf;
+    int n;
+    if (argint(0, &port) < 0) return -1;
+    if (port < 1 || port >= NPORT) return E_INVALID_ARG;
+    argstr(1, &buf);
+   if (argstr(1, &buf) < 0) return -1;
+    if (argint(2, &n) < 0) return -1;
+    //    if (argint(0, &port) < 0 && argstr(1, &buf) != 1 && argint(2, &n) != -1)
+    //        return -1;
+    //
+    // TODO: Write your code to get and validate port no., buffer and buffer size
+    //
+
+    return recv(port, buf, n);
+}
+
+int
+sys_disconnect(void) {
+    int port;
+     if (argint(0, &port) < 0) return -1;
+    if (port < 1 || port >= NPORT) return E_INVALID_ARG;
+
+    //
+    // TODO: Write your code to get and validate port no.
+    //
+
+    return disconnect(port);
+}
diff --git a/user.h b/user.h
index 4f99c52..55ebf5c 100644
--- a/user.h
+++ b/user.h
@@ -23,6 +23,11 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int listen(int);
+int connect(int, const char* host);
+int send(int, const char*, int);
+int recv(int, char*, int);
+int disconnect(int);
 
 // ulib.c
 int stat(const char*, struct stat*);
@@ -37,3 +42,11 @@ void* memset(void*, int, uint);
 void* malloc(uint);
 void free(void*);
 int atoi(const char*);
+
+
+//modifed
+#define E_NOTFOUND -1025
+#define E_ACCESS_DENIED -1026
+#define E_WRONG_STATE -1027
+#define E_FAIL -1028
+#define E_INVALID_ARG -1029
diff --git a/usys.S b/usys.S
index 8bfd8a1..2ac5ed0 100644
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,9 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(listen)
+SYSCALL(connect)
+SYSCALL(send)
+SYSCALL(recv)
+SYSCALL(disconnect)
+
diff --git a/xv6_SocketStub_patch b/xv6_SocketStub_patch
new file mode 100644
index 0000000..aebc3cd
--- /dev/null
+++ b/xv6_SocketStub_patch
@@ -0,0 +1,419 @@
+commit 02195eee285ee63f3aae983a85a6fdaec47fafd6
+Author: Saifur Rahman <saifur80@gmail.com>
+Date:   Sun Jan 13 22:07:13 2019 +0600
+
+    xv6 Socket API stub for students
+
+diff --git a/Makefile b/Makefile
+index 09d790c..e011a93 100644
+--- a/Makefile
++++ b/Makefile
+@@ -16,12 +16,14 @@ OBJS = \
+ 	pipe.o\
+ 	proc.o\
+ 	sleeplock.o\
++	sock.o\
+ 	spinlock.o\
+ 	string.o\
+ 	swtch.o\
+ 	syscall.o\
+ 	sysfile.o\
+ 	sysproc.o\
++	syssock.o\
+ 	trapasm.o\
+ 	trap.o\
+ 	uart.o\
+@@ -181,6 +183,7 @@ UPROGS=\
+ 	_usertests\
+ 	_wc\
+ 	_zombie\
++	_socktest\
+ 
+ fs.img: mkfs README $(UPROGS)
+ 	./mkfs fs.img README $(UPROGS)
+diff --git a/defs.h b/defs.h
+index 82fb982..ae6ae7e 100644
+--- a/defs.h
++++ b/defs.h
+@@ -121,6 +121,14 @@ int             wait(void);
+ void            wakeup(void*);
+ void            yield(void);
+ 
++// sock.c
++void            sinit(void);
++int             listen(int);
++int             connect(int, const char*);
++int             send(int, const char*, int);
++int             recv(int, char*, int);
++int             disconnect(int);
++
+ // swtch.S
+ void            swtch(struct context**, struct context*);
+ 
+diff --git a/main.c b/main.c
+index 9924e64..ac0b23e 100644
+--- a/main.c
++++ b/main.c
+@@ -4,6 +4,7 @@
+ #include "memlayout.h"
+ #include "mmu.h"
+ #include "proc.h"
++#include "sock.h"
+ #include "x86.h"
+ 
+ static void startothers(void);
+@@ -27,10 +28,11 @@ main(void)
+   consoleinit();   // console hardware
+   uartinit();      // serial port
+   pinit();         // process table
++  sinit();         // socket table
+   tvinit();        // trap vectors
+   binit();         // buffer cache
+   fileinit();      // file table
+-  ideinit();       // disk 
++  ideinit();       // disk
+   startothers();   // start other processors
+   kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
+   userinit();      // first user process
+diff --git a/param.h b/param.h
+index a7e90ef..f8e5027 100644
+--- a/param.h
++++ b/param.h
+@@ -1,3 +1,5 @@
++#define NPORT       128  // maximum number of ports
++#define NSOCK        32  // maximum number of sockets
+ #define NPROC        64  // maximum number of processes
+ #define KSTACKSIZE 4096  // size of per-process kernel stack
+ #define NCPU          8  // maximum number of CPUs
+diff --git a/sock.c b/sock.c
+new file mode 100644
+index 0000000..4d92581
+--- /dev/null
++++ b/sock.c
+@@ -0,0 +1,70 @@
++#include "types.h"
++#include "defs.h"
++#include "param.h"
++#include "spinlock.h"
++#include "sock.h"
++#include "memlayout.h"
++#include "mmu.h"
++#include "x86.h"
++#include "proc.h"
++
++//
++// TODO: Create a structure to maintain a list of sockets
++// Should it have locking?
++//
++
++void
++sinit(void)
++{
++  //
++  // TODO: Write any initialization code for socket API
++  // initialization.
++  //
++}
++
++int
++listen(int lport) {
++
++  //
++  // TODO: Put the actual implementation of listen here.
++  //
++
++  return 0;
++}
++
++int
++connect(int rport, const char* host) {
++  //
++  // TODO: Put the actual implementation of connect here.
++  //
++
++  return 0;
++}
++
++int
++send(int lport, const char* data, int n) {
++  //
++  // TODO: Put the actual implementation of send here.
++  //
++
++  return 0;
++}
++
++
++int
++recv(int lport, char* data, int n) {
++  //
++  // TODO: Put the actual implementation of recv here.
++  //
++
++  return 0;
++}
++
++int
++disconnect(int lport) {
++  //
++  // TODO: Put the actual implementation of disconnect here.
++  //
++
++  return 0;
++}
+diff --git a/sock.h b/sock.h
+new file mode 100644
+index 0000000..2ab24fe
+--- /dev/null
++++ b/sock.h
+@@ -0,0 +1,8 @@
++
++//
++// TODO: Define an enumeration to represent socket state.
++//
++
++//
++// TODO: Define a structure to represent a socket.
++//
+diff --git a/socktest.c b/socktest.c
+new file mode 100644
+index 0000000..b68a705
+--- /dev/null
++++ b/socktest.c
+@@ -0,0 +1,77 @@
++#include "types.h"
++#include "user.h"
++
++int serverPort = 10;
++
++void clientProc() {
++  int clientPort;
++  char buf[128];
++  char host[16] = "localhost";
++
++  // sleep for 100 clock ticks to ensure that the server process starts first.
++  sleep(100);
++
++  printf(1, "Client>> Attempting to connect to port %d, host %s ...\n", serverPort, host);
++  clientPort = connect(serverPort, host);
++  sleep(20);
++  printf(1, "Client>> connect() returned %d\n", clientPort);
++
++  while (1) {
++    printf(1, "Client>> Enter text to send to server: ");
++    gets(buf, sizeof(buf));
++    buf[strlen(buf) - 1] = '\0'; // Eliminating the '\n'
++    send(clientPort, buf, strlen(buf) + 1);
++
++    if (0 == strcmp(buf, "exit")) {
++      printf(1, "Client exiting...\n");
++      disconnect(clientPort);
++      break;
++    }
++
++    sleep(100 + uptime() % 100);
++
++    recv(clientPort, buf, sizeof(buf));
++    printf(1, "Client>> Received: \"%s\"\n", buf);
++  }
++}
++
++void serverProc() {
++  int status;
++  char buf[128];
++
++  printf(1, "Server>> Starting to listen at port %d ...\n", serverPort);
++  status = listen(serverPort);
++  printf(1, "Server>> listen() returned %d\n", status);
++
++  while (1) {
++    sleep(100 + uptime() % 100);
++
++    recv(serverPort, buf, sizeof(buf));
++    printf(1, "Server>> Received: \"%s\"\n", buf);
++
++    if (0 == strcmp(buf, "exit")) {
++      printf(1, "Server exiting...\n");
++      disconnect(serverPort);
++      break;
++    }
++
++    sleep(100 + uptime() % 100);
++
++    strcpy(buf+strlen(buf), " OK");
++    send(serverPort, buf, strlen(buf) + 1);
++  }
++}
++
++
++int main(int argc, char *argv[])
++{
++  if (0 == fork()) {
++    clientProc();
++    exit();
++  } else {
++    serverProc();
++    // This is the parent process. So, it needs to wait before client terminates
++    wait();
++    exit();
++  }
++}
+diff --git a/syscall.c b/syscall.c
+index ee85261..c06bb58 100644
+--- a/syscall.c
++++ b/syscall.c
+@@ -60,7 +60,7 @@ argptr(int n, char **pp, int size)
+ {
+   int i;
+   struct proc *curproc = myproc();
+- 
++
+   if(argint(n, &i) < 0)
+     return -1;
+   if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz)
+@@ -103,6 +103,11 @@ extern int sys_unlink(void);
+ extern int sys_wait(void);
+ extern int sys_write(void);
+ extern int sys_uptime(void);
++extern int sys_listen(void);
++extern int sys_connect(void);
++extern int sys_send(void);
++extern int sys_recv(void);
++extern int sys_disconnect(void);
+ 
+ static int (*syscalls[])(void) = {
+ [SYS_fork]    sys_fork,
+@@ -126,6 +131,11 @@ static int (*syscalls[])(void) = {
+ [SYS_link]    sys_link,
+ [SYS_mkdir]   sys_mkdir,
+ [SYS_close]   sys_close,
++[SYS_listen]  sys_listen,
++[SYS_connect] sys_connect,
++[SYS_send]    sys_send,
++[SYS_recv]    sys_recv,
++[SYS_disconnect] sys_disconnect
+ };
+ 
+ void
+diff --git a/syscall.h b/syscall.h
+index bc5f356..289fb4b 100644
+--- a/syscall.h
++++ b/syscall.h
+@@ -20,3 +20,8 @@
+ #define SYS_link   19
+ #define SYS_mkdir  20
+ #define SYS_close  21
++#define SYS_listen  22
++#define SYS_connect  23
++#define SYS_send  24
++#define SYS_recv  25
++#define SYS_disconnect  26
+diff --git a/syssock.c b/syssock.c
+new file mode 100644
+index 0000000..4c006af
+--- /dev/null
++++ b/syssock.c
+@@ -0,0 +1,73 @@
++#include "types.h"
++#include "defs.h"
++#include "param.h"
++#include "memlayout.h"
++#include "mmu.h"
++#include "x86.h"
++#include "proc.h"
++
++int
++sys_listen(void)
++{
++  int port = 0;
++
++  //
++  // TODO: Write your code to get and validate port no.
++  //
++
++  return listen(port);
++}
++
++int
++sys_connect(void)
++{
++  int port = 0;
++  char *host = 0;
++
++  //
++  // TODO: Write your code to get and validate port no., host.
++  // Allow connection to "localhost" or "127.0.0.1" host only
++  //
++
++  return connect(port, host);
++}
++
++int
++sys_send(void)
++{
++  int port = 0;
++  char* buf = 0;
++  int n = 0;
++
++  //
++  // TODO: Write your code to get and validate port no., buffer and buffer size
++  //
++
++  return send(port, buf, n);
++}
++
++int
++sys_recv(void)
++{
++  int port = 0;
++  char* buf = 0;
++  int n = 0;
++
++  //
++  // TODO: Write your code to get and validate port no., buffer and buffer size
++  //
++
++  return recv(port, buf, n);
++}
++
++int
++sys_disconnect(void)
++{
++  int port = 0;
++
++  //
++  // TODO: Write your code to get and validate port no.
++  //
++
++  return disconnect(port);
++}
+diff --git a/user.h b/user.h
+index 4f99c52..ce9f2f1 100644
+--- a/user.h
++++ b/user.h
+@@ -23,6 +23,11 @@ int getpid(void);
+ char* sbrk(int);
+ int sleep(int);
+ int uptime(void);
++int listen(int);
++int connect(int, const char* host);
++int send(int, const char*, int);
++int recv(int, char*, int);
++int disconnect(int);
+ 
+ // ulib.c
+ int stat(const char*, struct stat*);
+diff --git a/usys.S b/usys.S
+index 8bfd8a1..2ac5ed0 100644
+--- a/usys.S
++++ b/usys.S
+@@ -29,3 +29,9 @@ SYSCALL(getpid)
+ SYSCALL(sbrk)
+ SYSCALL(sleep)
+ SYSCALL(uptime)
++SYSCALL(listen)
++SYSCALL(connect)
++SYSCALL(send)
++SYSCALL(recv)
++SYSCALL(disconnect)
++
